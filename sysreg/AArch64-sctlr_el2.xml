<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE register_page SYSTEM "registers.dtd">
<!-- Copyright (c) 2010-2018 Arm Limited or its affiliates. All rights reserved. -->
<!-- This document is Non-Confidential. This document may only be used and distributed in accordance with the terms of the agreement entered into by Arm and the party that Arm delivered this document to. -->
<?xml-stylesheet href="one_register.xsl" type="text/xsl" ?>






<register_page>
  <registers>
    <register execution_state="AArch64" is_register="True" is_internal="True" is_banked="False" is_stub_entry="False">
      <reg_short_name>SCTLR_EL2</reg_short_name>
      <reg_long_name>System Control Register (EL2)</reg_long_name>
      
      

          <reg_reset_value>
            <reg_reset_limited_to_el>EL2</reg_reset_limited_to_el>

      </reg_reset_value>
      <reg_mappings>
          <reg_mapping>
              
            <mapped_name filename="AArch32-hsctlr.xml">HSCTLR</mapped_name>
            <mapped_type>Architectural</mapped_type>
              <mapped_execution_state>AArch32</mapped_execution_state>
              <mapped_from_startbit>31</mapped_from_startbit>
              <mapped_from_endbit>0</mapped_from_endbit>

              <mapped_to_startbit>31</mapped_to_startbit>
              <mapped_to_endbit>0</mapped_to_endbit>

          </reg_mapping>
      </reg_mappings>
      <reg_purpose>
        
    
      <purpose_text>
        <para>Provides top level control of the system, including its memory system, at EL2.</para>

      </purpose_text>
      <purpose_text>
        <para>When <xref browsertext="FEAT_VHE" filename="A_armv8_architecture_extensions.fm" linkend="v8.1.VHE"/> is implemented, and the value of <register_link state="AArch64" id="AArch64-hcr_el2.xml">HCR_EL2</register_link>.{E2H, TGE} is {1, 1}, these controls apply also to execution at EL0.</para>
      </purpose_text>

      </reg_purpose>
      <reg_groups>
            <reg_group>Virtualization registers</reg_group>
      </reg_groups>
      <reg_configuration>
        
    
      <configuration_text>
        <para>If EL2 is not implemented, this register is <arm-defined-word>RES0</arm-defined-word> from EL3.</para>

      </configuration_text>
      <configuration_text>
        <para>This register has no effect if EL2 is not enabled in the current Security state.</para>
      </configuration_text>

      </reg_configuration>
      <reg_attributes>
          <attributes_text>
            <para>SCTLR_EL2 is a 64-bit register.</para>
          </attributes_text>
      </reg_attributes>
      <reg_fieldsets>
        





  <fields length="64">
      <fields_condition>When HCR_EL2.E2H != 1 or HCR_EL2.TGE != 1</fields_condition>
      <fields_instance>HCR_EL2.{E2H, TGE} != {1, 1}</fields_instance>
    <text_before_fields>
      
  <para>This format applies in all Armv8.0 implementations, and from Armv8.1 when the Effective value of <register_link state="AArch64" id="AArch64-hcr_el2.xml">HCR_EL2</register_link>.{E2H, TGE} != {1, 1}.</para>

    </text_before_fields>
    
        <field
           id="0_63_45"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>63</field_msb>
          <field_lsb>45</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="DSSBS_44_44_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>DSSBS</field_name>
          <field_msb>44</field_msb>
          <field_lsb>44</field_lsb>
          <field_description order="before">
          
  <para>Default PSTATE.SSBS value on Exception Entry.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>PSTATE.SSBS is set to 0 on an exception to EL2.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>PSTATE.SSBS is set to 1 on an exception to EL2.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>ID</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_SSBS is implemented</fields_condition>
      </field>
        <field
           id="0_44_44_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>44</field_msb>
          <field_lsb>44</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="ATA_43_43_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>ATA</field_name>
          <field_msb>43</field_msb>
          <field_lsb>43</field_lsb>
          <field_description order="before">
          
  <para>Allocation Tag Access. When <register_link state="AArch64" id="AArch64-scr_el3.xml">SCR_EL3</register_link>.ATA=1, controls EL2 access to Allocation Tags.</para>
<para>When access to Allocation Tags is prevented:</para>
<list type="unordered">
<listitem><content>
<para>Instructions that Load or Store data are Unchecked.</para>
</content>
</listitem><listitem><content>
<para>Instructions that Load or Store Allocation Tags treat the Allocation Tag as RAZ/WI.</para>
</content>
</listitem><listitem><content>
<para>Instructions that insert Logical Address Tags into addresses treat the Allocation Tag used to generate the Logical Address Tag as 0.</para>
</content>
</listitem><listitem><content>
<para>Cache maintenance instructions that invalidate Allocation Tags from caches behave as the equivalent Clean and Invalidate operation on Allocation Tags.</para>
</content>
</listitem></list>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Access to Allocation Tags is prevented.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Access to Allocation Tags is not prevented.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>This bit is permitted to be cached in a TLB.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_MTE is implemented</fields_condition>
      </field>
        <field
           id="0_43_43_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>43</field_msb>
          <field_lsb>43</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="0_42_42"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>42</field_msb>
          <field_lsb>42</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="TCF_41_40_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>TCF</field_name>
          <field_msb>41</field_msb>
          <field_lsb>40</field_lsb>
           <field_range>41:40</field_range>
          <field_description order="before">
          
  <para>Tag Check Fault. Controls the effect of Tag Check Faults due to Loads and Stores in EL2.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b00</field_value>
        <field_value_description>
  <para>Tag Check Faults have no effect on the PE.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b01</field_value>
        <field_value_description>
  <para>Tag Check Faults cause a synchronous exception.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b10</field_value>
        <field_value_description>
  <para>Tag Check Faults are asynchronously accumulated.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>The value <binarynumber>0b11</binarynumber> is reserved.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_MTE is implemented</fields_condition>
      </field>
        <field
           id="0_41_40_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>41</field_msb>
          <field_lsb>40</field_lsb>
           <field_range>41:40</field_range>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="0_39_38"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>39</field_msb>
          <field_lsb>38</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="ITFSB_37_37_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>ITFSB</field_name>
          <field_msb>37</field_msb>
          <field_lsb>37</field_lsb>
          <field_description order="before">
          
  <para>When synchronous exceptions are not being generated by Tag Check Faults, which are generated for Loads and Stores in EL0, EL1 or EL2, controls the auto-synchronizaton of Tag Check Faults into <register_link state="AArch64" id="AArch64-tfsre0_el1.xml">TFSRE0_EL1</register_link>, <register_link state="AArch64" id="AArch64-tfsr_el1.xml">TFSR_EL1</register_link>, and <register_link state="AArch64" id="AArch64-tfsr_el2.xml">TFSR_EL2</register_link>.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Tag Check Faults are not synchronized on entry to EL2.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Tag Check Faults are synchronized on entry to EL2.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
</field_resets>
            <fields_condition>When FEAT_MTE is implemented</fields_condition>
      </field>
        <field
           id="0_37_37_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>37</field_msb>
          <field_lsb>37</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="BT_36_36_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>BT</field_name>
          <field_msb>36</field_msb>
          <field_lsb>36</field_lsb>
          <field_description order="before">
          
  <para>PAC Branch Type compatibility at EL2.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>When the PE is executing at EL2, PACIASP and PACIBSP are compatible with PSTATE.BTYPE == <binarynumber>0b11</binarynumber>.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>When the PE is executing at EL2, PACIASP and PACIBSP are not compatible with PSTATE.BTYPE == <binarynumber>0b11</binarynumber>.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_BTI is implemented</fields_condition>
      </field>
        <field
           id="0_36_36_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>36</field_msb>
          <field_lsb>36</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="0_35_32"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>35</field_msb>
          <field_lsb>32</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="EnIA_31_31_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>EnIA</field_name>
          <field_msb>31</field_msb>
          <field_lsb>31</field_lsb>
          <field_description order="before">
          
  <para>Controls enabling of pointer authentication (using the APIAKey_EL1 key) of instruction addresses in the EL2&amp;0 translation regime.</para>
<para>For more information, see <xref browsertext="'System register control of pointer authentication'" filename="D_the_aarch64_virtual_memory_system_architecture.fm" linkend="CHDCEIBG"></xref>.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Pointer authentication (using the APIAKey_EL1 key) of instruction addresses is not enabled.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Pointer authentication (using the APIAKey_EL1 key) of instruction addresses is enabled.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <note><para>This field controls the behavior of the AddPACIA and AuthIA pseudocode functions. Specifically, when the field is 1, AddPACIA returns a copy of a pointer to which a pointer authentication code has been added, and AuthIA returns an authenticated copy of a pointer. When the field is 0, both of these functions are NOP.</para></note>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_PAuth is implemented</fields_condition>
      </field>
        <field
           id="0_31_31_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>31</field_msb>
          <field_lsb>31</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="EnIB_30_30_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>EnIB</field_name>
          <field_msb>30</field_msb>
          <field_lsb>30</field_lsb>
          <field_description order="before">
          
  <para>Controls enabling of pointer authentication (using the APIBKey_EL1 key) of instruction addresses in the EL2&amp;0 translation regime.</para>
<para>For more information, see <xref browsertext="'System register control of pointer authentication'" filename="D_the_aarch64_virtual_memory_system_architecture.fm" linkend="CHDCEIBG"></xref>.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Pointer authentication (using the APIBKey_EL1 key) of instruction addresses is not enabled.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Pointer authentication (using the APIBKey_EL1 key) of instruction addresses is enabled.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <note><para>This field controls the behavior of the AddPACIB and AuthIB pseudocode functions. Specifically, when the field is 1, AddPACIB returns a copy of a pointer to which a pointer authentication code has been added, and AuthIB returns an authenticated copy of a pointer. When the field is 0, both of these functions are NOP.</para></note>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_PAuth is implemented</fields_condition>
      </field>
        <field
           id="0_30_30_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>30</field_msb>
          <field_lsb>30</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="1_29_28"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES1"
        >
          <field_name>1</field_name>
          <field_msb>29</field_msb>
          <field_lsb>28</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="EnDA_27_27_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>EnDA</field_name>
          <field_msb>27</field_msb>
          <field_lsb>27</field_lsb>
          <field_description order="before">
          
  <para>Controls enabling of pointer authentication (using the APDAKey_EL1 key) of instruction addresses in the EL2&amp;0 translation regime.</para>
<para>For more information, see <xref browsertext="'System register control of pointer authentication'" filename="D_the_aarch64_virtual_memory_system_architecture.fm" linkend="CHDCEIBG"></xref>.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Pointer authentication (using the APDAKey_EL1 key) of data addresses is not enabled.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Pointer authentication (using the APDAKey_EL1 key) of data addresses is enabled.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <note><para>This field controls the behavior of the AddPACDA and AuthDA pseudocode functions. Specifically, when the field is 1, AddPACDA returns a copy of a pointer to which a pointer authentication code has been added, and AuthDA returns an authenticated copy of a pointer. When the field is 0, both of these functions are NOP.</para></note>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_PAuth is implemented</fields_condition>
      </field>
        <field
           id="0_27_27_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>27</field_msb>
          <field_lsb>27</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="0_26_26"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>26</field_msb>
          <field_lsb>26</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="EE_25_25"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>EE</field_name>
          <field_msb>25</field_msb>
          <field_lsb>25</field_lsb>
          <field_description order="before">
          
  <para>Endianness of data accesses at EL2, stage 1 translation table walks in the EL2 or EL2&amp;0 translation regime, and stage 2 translation table walks in the EL1&amp;0 translation regime.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Explicit data accesses at EL2, stage 1 translation table walks in the EL2 or EL2&amp;0 translation regime, and stage 2 translation table walks in the EL1&amp;0 translation regime are little-endian.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Explicit data accesses at EL2, stage 1 translation table walks in the EL2 or EL2&amp;0 translation regime, and stage 2 translation table walks in the EL1&amp;0 translation regime are big-endian.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>If an implementation does not provide Big-endian support at Exception Levels higher than EL0, this bit is <arm-defined-word>RES0</arm-defined-word>.</para>
<para>If an implementation does not provide Little-endian support at Exception Levels higher than EL0, this bit is <arm-defined-word>RES1</arm-defined-word>.</para>
<para>The EE bit is permitted to be cached in a TLB.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>ID</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="0_24_24"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>24</field_msb>
          <field_lsb>24</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="1_23_23"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES1"
        >
          <field_name>1</field_name>
          <field_msb>23</field_msb>
          <field_lsb>23</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="EIS_22_22_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES1"
        >
          <field_name>EIS</field_name>
          <field_msb>22</field_msb>
          <field_lsb>22</field_lsb>
          <field_description order="before">
          
  <para>Exception entry is a context synchronization event. The defined values are:</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>The taking of an exception to EL2 is not a context synchronization event.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>The taking of an exception to EL2 is a context synchronization event.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>If SCTLR_EL2.EIS is set to <binarynumber>0b0</binarynumber>:</para>
<list type="unordered">
<listitem><content>Indirect writes to <register_link state="AArch64" id="AArch64-esr_el2.xml">ESR_EL2</register_link>, <register_link state="AArch64" id="AArch64-far_el2.xml">FAR_EL2</register_link>, <register_link state="AArch64" id="AArch64-spsr_el2.xml">SPSR_EL2</register_link>, <register_link state="AArch64" id="AArch64-elr_el2.xml">ELR_EL2</register_link>, and <register_link state="AArch64" id="AArch64-hpfar_el2.xml">HPFAR_EL2</register_link> are synchronized on exception entry to EL2, so that a direct read of the register after exception entry sees the indirectly written value caused by the exception entry.</content>
</listitem><listitem><content>Memory transactions, including instruction fetches, from an Exception level always use the translation resources associated with that translation regime.</content>
</listitem><listitem><content>Exception Catch debug events are synchronous debug events.</content>
</listitem><listitem><content>DCPS* and DRPS instructions are context synchronization events.</content>
</listitem></list>
<para>The following are not affected by the value of SCTLR_EL2.EIS:</para>
<list type="unordered">
<listitem><content>Changes to the PSTATE information on entry to EL2.</content>
</listitem><listitem><content>Behavior of accessing the banked copies of the stack pointer using the SP register name for loads, stores, and data processing instructions.</content>
</listitem><listitem><content>Exit from Debug state.</content>
</listitem></list>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_ExS is implemented</fields_condition>
      </field>
        <field
           id="1_22_22_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES1"
        >
          <field_name>1</field_name>
          <field_msb>22</field_msb>
          <field_lsb>22</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="IESB_21_21_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>IESB</field_name>
          <field_msb>21</field_msb>
          <field_lsb>21</field_lsb>
          <field_description order="before">
          
  <para>Implicit Error Synchronization event enable.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Disabled.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>An implicit error synchronization event is added:</para>
<list type="unordered">
<listitem><content>At each exception taken to EL2.</content>
</listitem><listitem><content>Before the operational pseudocode of each <instruction>ERET</instruction> instruction executed at EL2.</content>
</listitem></list>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>When the PE is in Debug state, the effect of this field is <arm-defined-word>CONSTRAINED UNPREDICTABLE</arm-defined-word>, and its Effective value might be 0 or 1 regardless of the value of the field. If the Effective value of the field is 1, then an implicit error synchronization event is added after each <instruction>DCPSx</instruction> instruction taken to EL2 and before each <instruction>DRPS</instruction> instruction executed at EL2, in addition to the other cases where it is added.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_IESB is implemented</fields_condition>
      </field>
        <field
           id="0_21_21_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>21</field_msb>
          <field_lsb>21</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="0_20_20"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>20</field_msb>
          <field_lsb>20</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="WXN_19_19"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>WXN</field_name>
          <field_msb>19</field_msb>
          <field_lsb>19</field_lsb>
          <field_description order="before">
          
  <para>Write permission implies XN (Execute-never). For the EL2 or EL2&amp;0 translation regime, this bit can force all memory regions that are writable to be treated as XN:</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>This control has no effect on memory access permissions.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Any region that is writable in the EL2 or EL2&amp;0 translation regime is forced to XN for accesses from software executing at EL2.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>This bit applies only when SCTLR_EL2.M bit is set.</para>
<para>The WXN bit is permitted to be cached in a TLB.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="1_18_18"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES1"
        >
          <field_name>1</field_name>
          <field_msb>18</field_msb>
          <field_lsb>18</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="0_17_17"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>17</field_msb>
          <field_lsb>17</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="1_16_16"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES1"
        >
          <field_name>1</field_name>
          <field_msb>16</field_msb>
          <field_lsb>16</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="0_15_14"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>15</field_msb>
          <field_lsb>14</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="EnDB_13_13_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>EnDB</field_name>
          <field_msb>13</field_msb>
          <field_lsb>13</field_lsb>
          <field_description order="before">
          
  <para>Controls enabling of pointer authentication (using the APDBKey_EL1 key) of instruction addresses in the EL2&amp;0 translation regime.</para>
<para>For more information, see <xref browsertext="'System register control of pointer authentication'" filename="D_the_aarch64_virtual_memory_system_architecture.fm" linkend="CHDCEIBG"></xref>.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Pointer authentication (using the APDBKey_EL1 key) of data addresses is not enabled.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Pointer authentication (using the APDBKey_EL1 key) of data addresses is enabled.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <note><para>This field controls the behavior of the AddPACDB and AuthDB pseudocode functions. Specifically, when the field is 1, AddPACDB returns a copy of a pointer to which a pointer authentication code has been added, and AuthDB returns an authenticated copy of a pointer. When the field is 0, both of these functions are NOP.</para></note>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_PAuth is implemented</fields_condition>
      </field>
        <field
           id="0_13_13_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>13</field_msb>
          <field_lsb>13</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="I_12_12"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>I</field_name>
          <field_msb>12</field_msb>
          <field_lsb>12</field_lsb>
          <field_description order="before">
          
  <para>Instruction access Cacheability control, for accesses at EL2:</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>All instruction accesses to Normal memory from EL2 are Non-cacheable for all levels of instruction and unified cache.</para>
<para>If the value of SCTLR_EL2.M is 0, instruction accesses from stage 1 of the EL2 or EL2&amp;0 translation regime are to Normal, Outer Shareable, Inner Non-cacheable, Outer Non-cacheable memory.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>This control has no effect on the Cacheability of instruction access to Normal memory from EL2.</para>
<para>If the value of SCTLR_EL2.M is 0, instruction accesses from stage 1 of the EL2 or EL2&amp;0 translation regime are to Normal, Outer Shareable, Inner Write-Through, Outer Write-Through memory.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>This bit has no effect on the EL1&amp;0 or EL3 translation regimes.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_number>0</field_reset_number>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="EOS_11_11_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES1"
        >
          <field_name>EOS</field_name>
          <field_msb>11</field_msb>
          <field_lsb>11</field_lsb>
          <field_description order="before">
          
  <para>Exception exit is a context synchronization Event.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>An exception return from EL2 is not a context synchronization event.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>An exception return from EL2 is a context synchronization event.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>If SCTLR_EL2.EOS is set to <binarynumber>0b0</binarynumber>:</para>
<list type="unordered">
<listitem><content>Memory transactions, including instruction fetches, from an Exception level always use the translation resources associated with that translation regime.</content>
</listitem><listitem><content>Exception Catch debug events are synchronous debug events.</content>
</listitem><listitem><content>DCPS* and DRPS instructions are context synchronization events.</content>
</listitem></list>
<para>The following are not affected by the value of SCTLR_EL2.EOS:</para>
<list type="unordered">
<listitem><content>The indirect write of the PSTATE and PC values from <register_link state="AArch64" id="AArch64-spsr_el2.xml">SPSR_EL2</register_link> and <register_link state="AArch64" id="AArch64-elr_el2.xml">ELR_EL2</register_link> on exception return is synchronized. </content>
</listitem><listitem><content>Behavior of accessing the banked copies of the stack pointer using the SP register name for loads, stores, and data processing instructions.</content>
</listitem><listitem><content>Exit from Debug state.</content>
</listitem></list>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_ExS is implemented</fields_condition>
      </field>
        <field
           id="1_11_11_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES1"
        >
          <field_name>1</field_name>
          <field_msb>11</field_msb>
          <field_lsb>11</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="0_10_7"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>10</field_msb>
          <field_lsb>7</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="nAA_6_6_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>nAA</field_name>
          <field_msb>6</field_msb>
          <field_lsb>6</field_lsb>
          <field_description order="before">
          
  <para>Non-aligned access. This bit controls generation of Alignment faults at EL2 under certain conditions.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>LDAPR, LDAPRH, LDAPUR, LDAPURH, LDAPURSH, LDAPURSW, LDAR, LDARH, LDLAR, LDLARH, STLLR, STLLRH, STLR, STLRH, STLUR, and STLURH generate an Alignment fault if all bytes being accessed are not within a single 16-byte quantity, aligned to 16 bytes for accesses.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>This control bit does not cause LDAPR, LDAPRH, LDAPUR, LDAPURH, LDAPURSH, LDAPURSW, LDAR, LDARH, LDLAR, LDLARH, STLLR, STLLRH, STLR, STLRH, STLUR, or STLURH to generate an Alignment fault if all bytes being accessed are not within a single 16-byte quantity, aligned to 16 bytes.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_LSE2 is implemented</fields_condition>
      </field>
        <field
           id="0_6_6_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>6</field_msb>
          <field_lsb>6</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="1_5_4"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES1"
        >
          <field_name>1</field_name>
          <field_msb>5</field_msb>
          <field_lsb>4</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="SA_3_3"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>SA</field_name>
          <field_msb>3</field_msb>
          <field_lsb>3</field_lsb>
          <field_description order="before">
          
  <para>SP Alignment check enable. When set to 1, if a load or store instruction executed at EL2 uses the SP as the base address and the SP is not aligned to a 16-byte boundary, then an SP alignment fault exception is generated. For more information, see <xref browsertext="'SP alignment checking'" filename="D_the_aarch64_system_level_programmers_model.fm" linkend="BEIHDCIE"></xref>.</para>

          </field_description>
            <field_values>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="C_2_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>C</field_name>
          <field_msb>2</field_msb>
          <field_lsb>2</field_lsb>
          <field_description order="before">
          
  <para>Cacheability control, for data accesses.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>All data accesses to Normal memory from EL2, and all Normal memory accesses to the EL2 translation tables, are Non-cacheable for all levels of data and unified cache.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>This control has no effect on the Cacheability of:</para>
<list type="unordered">
<listitem><content>
<para>Data access to Normal memory from EL2.</para>
</content>
</listitem><listitem><content>
<para>Normal memory accesses to the EL2 translation tables.</para>
</content>
</listitem></list>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>This bit has no effect on the EL1&amp;0 or EL3 translation regimes.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_number>0</field_reset_number>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="A_1_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>A</field_name>
          <field_msb>1</field_msb>
          <field_lsb>1</field_lsb>
          <field_description order="before">
          
  <para>Alignment check enable. This is the enable bit for Alignment fault checking at EL2:</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Alignment fault checking disabled when executing at EL2.</para>
<para>Instructions that load or store one or more registers, other than load/store exclusive and load-acquire/store-release, do not check that the address being accessed is aligned to the size of the data element(s) being accessed.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Alignment fault checking enabled when executing at EL2.</para>
<para>All instructions that load or store one or more registers have an alignment check that the address being accessed is aligned to the size of the data element(s) being accessed. If this check fails it causes an Alignment fault, which is taken as a Data Abort exception.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>Load/store exclusive and load-acquire/store-release instructions have an alignment check regardless of the value of the A bit.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="M_0_0"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>M</field_name>
          <field_msb>0</field_msb>
          <field_lsb>0</field_lsb>
          <field_description order="before">
          
  <para>MMU enable for EL2 stage 1 address translation.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>EL2 stage 1 address translation disabled.</para>
<para>See the SCTLR_EL2.I field for the behavior of instruction accesses to Normal memory.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>EL2 stage 1 address translation enabled.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_number>0</field_reset_number>
  
        </field_reset>
  
</field_resets>
      </field>
    <text_after_fields>
    
  

    </text_after_fields>
  </fields>
  <fields length="64">
      <fields_condition>When HCR_EL2.E2H == 1 and HCR_EL2.TGE == 1</fields_condition>
      <fields_instance>HCR_EL2.{E2H, TGE} == {1, 1}</fields_instance>
    <text_before_fields>
      
  <para>This format applies only from Armv8.1 when EL2 is enabled in the current Security state and <register_link state="AArch64" id="AArch64-hcr_el2.xml">HCR_EL2</register_link>.{E2H, TGE} == {1, 1}.</para>

    </text_before_fields>
    
        <field
           id="0_63_50"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>63</field_msb>
          <field_lsb>50</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="TWEDEL_49_46_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="True"
           reserved_type="RES0"
        >
          <field_name>TWEDEL</field_name>
          <field_msb>49</field_msb>
          <field_lsb>46</field_lsb>
           <field_range>46</field_range>
          <field_description order="before">
          
  <para>TWE Delay. A 4-bit unsigned number that, when SCTLR_EL2.TWEDEn is 1, encodes the minimum delay in taking a trap of WFE caused by SCTLR_EL2.nTWE as 2^(TWEDEL + 8) cycles.</para>

          </field_description>
            <field_values>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_TWED is implemented</fields_condition>
      </field>
        <field
           id="0_49_46_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>49</field_msb>
          <field_lsb>46</field_lsb>
           <field_range>49:46</field_range>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="TWEDEn_45_45_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>TWEDEn</field_name>
          <field_msb>45</field_msb>
          <field_lsb>45</field_lsb>
          <field_description order="before">
          
  <para>TWE Delay Enable. Enables a configurable delayed trap of the WFE instruction caused by SCTLR_EL2.nTWE.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>The delay for taking a WFE trap is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word>.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>The delay for taking a WFE trap is at least the number of cycles defined in SCTLR_EL2.TWEDEL.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_TWED is implemented</fields_condition>
      </field>
        <field
           id="0_45_45_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>45</field_msb>
          <field_lsb>45</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="DSSBS_44_44_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>DSSBS</field_name>
          <field_msb>44</field_msb>
          <field_lsb>44</field_lsb>
          <field_description order="before">
          
  <para>Default PSTATE.SSBS value on Exception Entry.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>PSTATE.SSBS is set to 0 on an exception to EL2.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>PSTATE.SSBS is set to 1 on an exception to EL2.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>ID</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_SSBS is implemented</fields_condition>
      </field>
        <field
           id="0_44_44_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>44</field_msb>
          <field_lsb>44</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="ATA_43_43_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>ATA</field_name>
          <field_msb>43</field_msb>
          <field_lsb>43</field_lsb>
          <field_description order="before">
          
  <para>Allocation Tag Access in EL2. When SCR_EL3.ATA=1, controls EL2 access to Allocation Tags.</para>
<para>When access to Allocation Tags is prevented:</para>
<list type="unordered">
<listitem><content>
<para>Instructions which Load or Store data are Unchecked.</para>
</content>
</listitem><listitem><content>
<para>Instructions which Load or Store Allocation Tags treat the Allocation Tag as RAZ/WI.</para>
</content>
</listitem><listitem><content>
<para>Instructions which insert Logical Address Tags into addresses treat the Allocation Tag used to generate the Logical Address Tag as 0.</para>
</content>
</listitem><listitem><content>
<para>Cache maintenance instructions which invalidate Allocation Tags from caches behave as the equivalent Clean and Invalidate operation on Allocation Tags.</para>
</content>
</listitem></list>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Access to Allocation Tags is prevented.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Access to Allocation Tags is not prevented.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>This bit is permitted to be cached in a TLB.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_MTE is implemented</fields_condition>
      </field>
        <field
           id="0_43_43_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>43</field_msb>
          <field_lsb>43</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="ATA0_42_42_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>ATA0</field_name>
          <field_msb>42</field_msb>
          <field_lsb>42</field_lsb>
          <field_description order="before">
          
  <para>Allocation Tag Access in EL0. When <register_link state="AArch64" id="AArch64-scr_el3.xml">SCR_EL3</register_link>.ATA=1, controls EL0 access to Allocation Tags.</para>
<para>When access to Allocation Tags is prevented:</para>
<list type="unordered">
<listitem><content>
<para>Instructions which Load or Store data are Unchecked.</para>
</content>
</listitem><listitem><content>
<para>Instructions which Load or Store Allocation Tags treat the Allocation Tag as RAZ/WI.</para>
</content>
</listitem><listitem><content>
<para>Instructions which insert Logical Address Tags into addresses treat the Allocation Tag used to generate the Logical Address Tag as 0.</para>
</content>
</listitem><listitem><content>
<para>Cache maintenance instructions which invalidate Allocation Tags from caches behave as the equivalent Clean and Invalidate operation on Allocation Tags.</para>
</content>
</listitem></list>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Access to Allocation Tags is prevented.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Access to Allocation Tags is not prevented.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>This field is permitted to be cached in a TLB.</para>
<note><para>Software may change this control bit on a context switch.</para></note>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_MTE is implemented</fields_condition>
      </field>
        <field
           id="0_42_42_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>42</field_msb>
          <field_lsb>42</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="TCF_41_40_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>TCF</field_name>
          <field_msb>41</field_msb>
          <field_lsb>40</field_lsb>
           <field_range>41:40</field_range>
          <field_description order="before">
          
  <para>Tag Check Fault in EL2. Controls the effect of Tag Check Faults due to Loads and Stores in EL2.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b00</field_value>
        <field_value_description>
  <para>Tag Check Faults have no effect on the PE.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b01</field_value>
        <field_value_description>
  <para>Tag Check Faults cause a synchronous exception.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b10</field_value>
        <field_value_description>
  <para>Tag Check Faults are asynchronously accumulated.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>The value <binarynumber>0b11</binarynumber> is reserved.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_MTE is implemented</fields_condition>
      </field>
        <field
           id="0_41_40_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>41</field_msb>
          <field_lsb>40</field_lsb>
           <field_range>41:40</field_range>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="TCF0_39_38_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>TCF0</field_name>
          <field_msb>39</field_msb>
          <field_lsb>38</field_lsb>
           <field_range>39:38</field_range>
          <field_description order="before">
          
  <para>Tag Check Fault in EL0. Controls the effect of Tag Check Faults due to Loads and Stores in EL0.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b00</field_value>
        <field_value_description>
  <para>Tag Check Faults have no effect on the PE.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b01</field_value>
        <field_value_description>
  <para>Tag Check Faults cause a synchronous exception.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b10</field_value>
        <field_value_description>
  <para>Tag Check Faults are asynchronously accumulated.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>The value <binarynumber>0b11</binarynumber> is reserved.</para>
<note><para>Software may change this control bit on a context switch.</para></note>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_MTE is implemented</fields_condition>
      </field>
        <field
           id="0_39_38_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>39</field_msb>
          <field_lsb>38</field_lsb>
           <field_range>39:38</field_range>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="ITFSB_37_37_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>ITFSB</field_name>
          <field_msb>37</field_msb>
          <field_lsb>37</field_lsb>
          <field_description order="before">
          
  <para>When synchronous exceptions are not being generated by Tag Check Faults which are generated for Loads and Stores in EL0, EL1 or EL2, controls the auto-synchronizaton of Tag Check Faults into <register_link state="AArch64" id="AArch64-tfsre0_el1.xml">TFSRE0_EL1</register_link>, <register_link state="AArch64" id="AArch64-tfsr_el1.xml">TFSR_EL1</register_link> and <register_link state="AArch64" id="AArch64-tfsr_el2.xml">TFSR_EL2</register_link>.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Tag Check Faults are not synchronized on entry to EL2.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Tag Check Faults are synchronized on entry to EL2.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_MTE is implemented</fields_condition>
      </field>
        <field
           id="0_37_37_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>37</field_msb>
          <field_lsb>37</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="BT1_36_36_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>BT1</field_name>
          <field_msb>36</field_msb>
          <field_lsb>36</field_lsb>
          <field_description order="before">
          
  <para>PAC Branch Type compatibility at EL2.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>When the PE is executing at EL2, PACIASP and PACIBSP are compatible with PSTATE.BTYPE == <binarynumber>0b11</binarynumber>.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>When the PE is executing at EL2, PACIASP and PACIBSP are not compatible with PSTATE.BTYPE == <binarynumber>0b11</binarynumber>.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_BTI is implemented</fields_condition>
      </field>
        <field
           id="0_36_36_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>36</field_msb>
          <field_lsb>36</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="BT0_35_35_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>BT0</field_name>
          <field_msb>35</field_msb>
          <field_lsb>35</field_lsb>
          <field_description order="before">
          
  <para>PAC Branch Type compatibility at EL0.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>When the PE is executing at EL0, PACIASP and PACIBSP are compatible with PSTATE.BTYPE == <binarynumber>0b11</binarynumber>.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>When the PE is executing at EL0, PACIASP and PACIBSP are not compatible with PSTATE.BTYPE == <binarynumber>0b11</binarynumber>.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_BTI is implemented</fields_condition>
      </field>
        <field
           id="0_35_35_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>35</field_msb>
          <field_lsb>35</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="0_34_32"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>34</field_msb>
          <field_lsb>32</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="EnIA_31_31_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>EnIA</field_name>
          <field_msb>31</field_msb>
          <field_lsb>31</field_lsb>
          <field_description order="before">
          
  <para>Controls enabling of pointer authentication (using the APIAKey_EL1 key) of instruction addresses in the EL2&amp;0 translation regime.</para>
<para>For more information, see <xref browsertext="'System register control of pointer authentication'" filename="D_the_aarch64_virtual_memory_system_architecture.fm" linkend="CHDCEIBG"></xref>.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Pointer authentication (using the APIAKey_EL1 key) of instruction addresses is not enabled.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Pointer authentication (using the APIAKey_EL1 key) of instruction addresses is enabled.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <note><para>This field controls the behavior of the AddPACIA and AuthIA pseudocode functions. Specifically, when the field is 1, AddPACIA returns a copy of a pointer to which a pointer authentication code has been added, and AuthIA returns an authenticated copy of a pointer. When the field is 0, both of these functions are NOP.</para></note>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_PAuth is implemented</fields_condition>
      </field>
        <field
           id="0_31_31_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>31</field_msb>
          <field_lsb>31</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="EnIB_30_30_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>EnIB</field_name>
          <field_msb>30</field_msb>
          <field_lsb>30</field_lsb>
          <field_description order="before">
          
  <para>Controls enabling of pointer authentication (using the APIBKey_EL1 key) of instruction addresses in the EL2&amp;0 translation regime.</para>
<para>For more information, see <xref browsertext="'System register control of pointer authentication'" filename="D_the_aarch64_virtual_memory_system_architecture.fm" linkend="CHDCEIBG"></xref>.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Pointer authentication (using the APIBKey_EL1 key) of instruction addresses is not enabled.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Pointer authentication (using the APIBKey_EL1 key) of instruction addresses is enabled.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <note><para>This field controls the behavior of the AddPACIB and AuthIB pseudocode functions. Specifically, when the field is 1, AddPACIB returns a copy of a pointer to which a pointer authentication code has been added, and AuthIB returns an authenticated copy of a pointer. When the field is 0, both of these functions are NOP.</para></note>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_PAuth is implemented</fields_condition>
      </field>
        <field
           id="0_30_30_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>30</field_msb>
          <field_lsb>30</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="LSMAOE_29_29_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES1"
        >
          <field_name>LSMAOE</field_name>
          <field_msb>29</field_msb>
          <field_lsb>29</field_lsb>
          <field_description order="before">
          
  <para>Load Multiple and Store Multiple Atomicity and Ordering Enable.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>For all memory accesses at EL0, A32 and T32 Load Multiple and Store Multiple can have an interrupt taken during the sequence memory accesses, and the memory accesses are not required to be ordered.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>The ordering and interrupt behavior of A32 and T32 Load Multiple and Store Multiple at EL0 is as defined for Armv8.0.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>This bit is permitted to be cached in a TLB.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_LSMAOC is implemented</fields_condition>
      </field>
        <field
           id="1_29_29_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES1"
        >
          <field_name>1</field_name>
          <field_msb>29</field_msb>
          <field_lsb>29</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="nTLSMD_28_28_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES1"
        >
          <field_name>nTLSMD</field_name>
          <field_msb>28</field_msb>
          <field_lsb>28</field_lsb>
          <field_description order="before">
          
  <para>No Trap Load Multiple and Store Multiple to Device-nGRE/Device-nGnRE/Device-nGnRnE memory.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>All memory accesses by A32 and T32 Load Multiple and Store Multiple at EL0 that are marked at stage 1 as Device-nGRE/Device-nGnRE/Device-nGnRnE memory are trapped and generate a stage 1 Alignment fault.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>All memory accesses by A32 and T32 Load Multiple and Store Multiple at EL0 that are marked at stage 1 as Device-nGRE/Device-nGnRE/Device-nGnRnE memory are not trapped.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>This bit is permitted to be cached in a TLB.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_LSMAOC is implemented</fields_condition>
      </field>
        <field
           id="1_28_28_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES1"
        >
          <field_name>1</field_name>
          <field_msb>28</field_msb>
          <field_lsb>28</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="EnDA_27_27_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>EnDA</field_name>
          <field_msb>27</field_msb>
          <field_lsb>27</field_lsb>
          <field_description order="before">
          
  <para>Controls enabling of pointer authentication (using the APDAKey_EL1 key) of instruction addresses in the EL2&amp;0 translation regime.</para>
<para>For more information, see <xref browsertext="'System register control of pointer authentication'" filename="D_the_aarch64_virtual_memory_system_architecture.fm" linkend="CHDCEIBG"></xref>.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Pointer authentication (using the APDAKey_EL1 key) of data addresses is not enabled.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Pointer authentication (using the APDAKey_EL1 key) of data addresses is enabled.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <note><para>This field controls the behavior of the AddPACDA and AuthDA pseudocode functions. Specifically, when the field is 1, AddPACDA returns a copy of a pointer to which a pointer authentication code has been added, and AuthDA returns an authenticated copy of a pointer. When the field is 0, both of these functions are NOP.</para></note>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_PAuth is implemented</fields_condition>
      </field>
        <field
           id="0_27_27_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>27</field_msb>
          <field_lsb>27</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="UCI_26_26"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>UCI</field_name>
          <field_msb>26</field_msb>
          <field_lsb>26</field_lsb>
          <field_description order="before">
          
  <para>Traps execution of cache maintenance instructions at EL0 to EL2, from AArch64 state only. This applies to <register_link id="AArch64-dc-cvau.xml" state="AArch64">DC CVAU</register_link>, <register_link id="AArch64-dc-civac.xml" state="AArch64">DC CIVAC</register_link>, <register_link id="AArch64-dc-cvac.xml" state="AArch64">DC CVAC</register_link>, <register_link id="AArch64-dc-cvap.xml" state="AArch64">DC CVAP</register_link>, and <register_link id="AArch64-ic-ivau.xml" state="AArch64">IC IVAU</register_link>.</para>
<para>If <xref browsertext="FEAT_DPB2" filename="A_armv8_architecture_extensions.fm" linkend="v8.2.DCCVADP"></xref> is implemented, this trap also applies to <register_link id="AArch64-dc-cvadp.xml" state="AArch64">DC CVADP</register_link>.</para>
<para>If <xref browsertext="FEAT_MTE" filename="A_armv8_architecture_extensions.fm" linkend="v8.5.MemTag"></xref> is implemented, this trap also applies to <register_link id="AArch64-dc-cigvac.xml" state="AArch64">DC CIGVAC</register_link>, <register_link id="AArch64-dc-cigdvac.xml" state="AArch64">DC CIGDVAC</register_link>, <register_link id="AArch64-dc-cgvac.xml" state="AArch64">DC CGVAC</register_link>, <register_link id="AArch64-dc-cgdvac.xml" state="AArch64">DC CGDVAC</register_link>, <register_link id="AArch64-dc-cgvap.xml" state="AArch64">DC CGVAP</register_link>, and <register_link id="AArch64-dc-cgdvap.xml" state="AArch64">DC CGDVAP</register_link>.</para>
<para>If <xref browsertext="FEAT_DPB2" filename="A_armv8_architecture_extensions.fm" linkend="v8.2.DCCVADP"></xref> and <xref browsertext="FEAT_MTE" filename="A_armv8_architecture_extensions.fm" linkend="v8.5.MemTag"></xref> are implemented, this trap also applies to <register_link id="AArch64-dc-cgvadp.xml" state="AArch64">DC CGVADP</register_link> and <register_link id="AArch64-dc-cgdvadp.xml" state="AArch64">DC CGDVADP</register_link>.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Any attempt to execute an instruction that this trap applies to at EL0 using AArch64 is trapped to EL2.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>This control does not cause any instructions to be trapped.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>If the Point of Coherency is before any level of data cache, it is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> whether the execution of any data or unified cache clean, or clean and invalidate instruction that operates by VA to the point of coherency can be trapped when the value of this control is 1.</para>
<para>If the Point of Unification is before any level of data cache, it is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> whether the execution of any data or unified cache clean by VA to the Point of Unification instruction can be trapped when the value of this control is 1.</para>
<para>If the Point of Unification is before any level of instruction cache, it is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> whether the execution of any instruction cache invalidate by VA to the Point of Unification instruction can be trapped when the value of this control is 1.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="EE_25_25"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>EE</field_name>
          <field_msb>25</field_msb>
          <field_lsb>25</field_lsb>
          <field_description order="before">
          
  <para>Endianness of data accesses at EL2, stage 1 translation table walks in the EL2 or EL2&amp;0 translation regime, and stage 2 translation table walks in the EL2&amp;0 translation regime.</para>
<para>The possible values of this bit are:</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Explicit data accesses at EL2, stage 1 translation table walks in the EL2 or EL2&amp;0 translation regime, and stage 2 translation table walks in the EL2&amp;0 translation regime are little-endian.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Explicit data accesses at EL2, stage 1 translation table walks in the EL2 or EL2&amp;0 translation regime, and stage 2 translation table walks in the EL2&amp;0 translation regime are big-endian.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>If an implementation does not provide Big-endian support at Exception Levels higher than EL0, this bit is <arm-defined-word>RES0</arm-defined-word>.</para>
<para>If an implementation does not provide Little-endian support at Exception Levels higher than EL0, this bit is <arm-defined-word>RES1</arm-defined-word>.</para>
<para>The EE bit is permitted to be cached in a TLB.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>ID</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="E0E_24_24"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>E0E</field_name>
          <field_msb>24</field_msb>
          <field_lsb>24</field_lsb>
          <field_description order="before">
          
  <para>Endianness of data accesses at EL0.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Explicit data accesses at EL0 are little-endian.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Explicit data accesses at EL0 are big-endian.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>If an implementation only supports Little-endian accesses at EL0 then this bit is <arm-defined-word>RES0</arm-defined-word>. This option is not permitted when SCTLR_EL1.EE is <arm-defined-word>RES1</arm-defined-word>.</para>
<para>If an implementation only supports Big-endian accesses at EL0 then this bit is <arm-defined-word>RES1</arm-defined-word>. This option is not permitted when SCTLR_EL1.EE is <arm-defined-word>RES0</arm-defined-word>.</para>
<para>This bit has no effect on the endianness of <instruction>LDTR</instruction>, <instruction>LDTRH</instruction>, <instruction>LDTRSH</instruction>, <instruction>LDTRSW</instruction>, <instruction>STTR</instruction>, and <instruction>STTRH</instruction> instructions executed at EL1.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="SPAN_23_23"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>SPAN</field_name>
          <field_msb>23</field_msb>
          <field_lsb>23</field_lsb>
          <field_description order="before">
          
  <para>Set Privileged Access Never, on taking an exception to EL2.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>PSTATE.PAN is set to 1 on taking an exception to EL2.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>The value of PSTATE.PAN is left unchanged on taking an exception to EL2.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="EIS_22_22_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES1"
        >
          <field_name>EIS</field_name>
          <field_msb>22</field_msb>
          <field_lsb>22</field_lsb>
          <field_description order="before">
          
  <para>Exception Entry is a context synchronization event.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>The taking of an exception to EL2 is not a context synchronization event.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>The taking of an exception to EL2 is a context synchronization event.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>If SCTLR_EL2.EIS is set to <binarynumber>0b0</binarynumber>:</para>
<list type="unordered">
<listitem><content>Indirect writes to <register_link state="AArch64" id="AArch64-esr_el2.xml">ESR_EL2</register_link>, <register_link state="AArch64" id="AArch64-far_el2.xml">FAR_EL2</register_link>, <register_link state="AArch64" id="AArch64-spsr_el2.xml">SPSR_EL2</register_link>, <register_link state="AArch64" id="AArch64-elr_el2.xml">ELR_EL2</register_link>, <register_link state="AArch64" id="AArch64-hpfar_el2.xml">HPFAR_EL2</register_link> are synchronized on exception entry to EL2, so that a direct read of the register after exception entry sees the indirectly written value caused by the exception entry.</content>
</listitem><listitem><content>Memory transactions, including instruction fetches, from an Exception level always use the translation resources associated with that translation regime.</content>
</listitem><listitem><content>Exception Catch debug events are synchronous debug events.</content>
</listitem><listitem><content>DCPS* and DRPS instructions are context synchronization events.</content>
</listitem></list>
<para>The following are not affected by the value of SCTLR_EL2.EIS:</para>
<list type="unordered">
<listitem><content>Changes to the PSTATE information on entry to EL2.</content>
</listitem><listitem><content>Behavior of accessing the banked copies of the stack pointer using the SP register name for loads, stores and data processing instructions.</content>
</listitem><listitem><content>Exit from Debug state.</content>
</listitem></list>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_ExS is implemented</fields_condition>
      </field>
        <field
           id="1_22_22_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES1"
        >
          <field_name>1</field_name>
          <field_msb>22</field_msb>
          <field_lsb>22</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="IESB_21_21_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>IESB</field_name>
          <field_msb>21</field_msb>
          <field_lsb>21</field_lsb>
          <field_description order="before">
          
  <para>Implicit Error Synchronization event Enable.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Disabled.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>An implicit error synchronization event is added:</para>
<list type="unordered">
<listitem><content>After each exception taken to EL2.</content>
</listitem><listitem><content>Before the operational pseudocode of each ERET instruction executed at EL2.</content>
</listitem></list>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>When the PE is in Debug state, the effect of this field is <arm-defined-word>CONSTRAINED UNPREDICTABLE</arm-defined-word>, and its Effective value might be 0 or 1 regardless of the value of the field. If the Effective value of the field is 1, then an implicit error synchronization event is added after each DCPSx instruction taken to EL2 and before each DRPS instruction executed at EL2, in addition to the other cases where it is added.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_IESB is implemented</fields_condition>
      </field>
        <field
           id="0_21_21_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>21</field_msb>
          <field_lsb>21</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="TSCXT_20_20_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES1"
        >
          <field_name>TSCXT</field_name>
          <field_msb>20</field_msb>
          <field_lsb>20</field_lsb>
          <field_description order="before">
          
  <para>Trap EL0 Access to the SCXTNUM_EL0 register, when EL0 is using AArch64.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>EL0 access to <register_link state="AArch64" id="AArch64-scxtnum_el0.xml">SCXTNUM_EL0</register_link> is not disabled by this mechanism.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>EL0 access to <register_link state="AArch64" id="AArch64-scxtnum_el0.xml">SCXTNUM_EL0</register_link> is disabled, causing an exception to EL2, and the <register_link state="AArch64" id="AArch64-scxtnum_el0.xml">SCXTNUM_EL0</register_link> value is treated at 0.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_CSV2 is implemented</fields_condition>
      </field>
        <field
           id="1_20_20_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES1"
        >
          <field_name>1</field_name>
          <field_msb>20</field_msb>
          <field_lsb>20</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="WXN_19_19"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>WXN</field_name>
          <field_msb>19</field_msb>
          <field_lsb>19</field_lsb>
          <field_description order="before">
          
  <para>Write permission implies XN (Execute-never). For the EL2 or EL2&amp;0 translation regime, this bit can force all memory regions that are writable to be treated as XN. The possible values of this bit are:</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>This control has no effect on memory access permissions.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Any region that is writable in the EL2 or EL2&amp;0 translation regime is forced to XN for accesses from software executing at EL2.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>This bit applies only when SCTLR_EL2.M bit is set.</para>
<para>The WXN bit is permitted to be cached in a TLB.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="nTWE_18_18"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>nTWE</field_name>
          <field_msb>18</field_msb>
          <field_lsb>18</field_lsb>
          <field_description order="before">
          
  <para>Traps execution of WFE instructions at EL0 to EL2, from both Execution states.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Any attempt to execute a WFE instruction at EL0 is trapped to EL2, if the instruction would otherwise have caused the PE to enter a low-power state.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>This control does not cause any instructions to be trapped.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>In AArch32 state, the attempted execution of a conditional WFE instruction is only trapped if the instruction passes its condition code check.</para>
<note><para>Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</para></note>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="0_17_17"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>17</field_msb>
          <field_lsb>17</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="nTWI_16_16"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>nTWI</field_name>
          <field_msb>16</field_msb>
          <field_lsb>16</field_lsb>
          <field_description order="before">
          
  <para>Traps execution of WFI instructions at EL0 to EL2, from both Execution states.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Any attempt to execute a WFI instruction at EL0 is trapped EL2, if the instruction would otherwise have caused the PE to enter a low-power state.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>This control does not cause any instructions to be trapped.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>In AArch32 state, the attempted execution of a conditional WFI instruction is only trapped if the instruction passes its condition code check.</para>
<note><para>Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</para></note>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="UCT_15_15"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>UCT</field_name>
          <field_msb>15</field_msb>
          <field_lsb>15</field_lsb>
          <field_description order="before">
          
  <para>Traps EL0 accesses to the <register_link state="AArch64" id="AArch64-ctr_el0.xml">CTR_EL0</register_link> to EL2, from AArch64 state only.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Accesses to the <register_link state="AArch64" id="AArch64-ctr_el0.xml">CTR_EL0</register_link> from EL0 using AArch64 are trapped to EL2.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>This control does not cause any instructions to be trapped.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="DZE_14_14"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>DZE</field_name>
          <field_msb>14</field_msb>
          <field_lsb>14</field_lsb>
          <field_description order="before">
          
  <para>Traps execution of <register_link id="AArch64-dc-zva.xml" state="AArch64">DC ZVA</register_link> instructions at EL0 to EL2, from AArch64 state only.</para>
<para>If <xref browsertext="FEAT_MTE" filename="A_armv8_architecture_extensions.fm" linkend="v8.5.MemTag"></xref> is implemented, this trap also applies to <register_link id="AArch64-dc-gva.xml" state="AArch64">DC GVA</register_link> and <register_link id="AArch64-dc-gzva.xml" state="AArch64">DC GZVA</register_link>.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Any attempt to execute an instruction that this trap applies to at EL0 using AArch64 is trapped to EL2. Reading <register_link state="AArch64" id="AArch64-dczid_el0.xml">DCZID_EL0</register_link>.DZP from EL0 returns 1, indicating that the instructions that this trap applies to are not supported.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>This control does not cause any instructions to be trapped.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="EnDB_13_13_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>EnDB</field_name>
          <field_msb>13</field_msb>
          <field_lsb>13</field_lsb>
          <field_description order="before">
          
  <para>Controls enabling of pointer authentication (using the APDBKey_EL1 key) of instruction addresses in the EL2&amp;0 translation regime.</para>
<para>For more information, see <xref browsertext="'System register control of pointer authentication'" filename="D_the_aarch64_virtual_memory_system_architecture.fm" linkend="CHDCEIBG"></xref>.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Pointer authentication (using the APDBKey_EL1 key) of data addresses is not enabled.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Pointer authentication (using the APDBKey_EL1 key) of data addresses is enabled.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <note><para>This field controls the behavior of the AddPACDB and AuthDB pseudocode functions. Specifically, when the field is 1, AddPACDB returns a copy of a pointer to which a pointer authentication code has been added, and AuthDB returns an authenticated copy of a pointer. When the field is 0, both of these functions are NOP.</para></note>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_PAuth is implemented</fields_condition>
      </field>
        <field
           id="0_13_13_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>13</field_msb>
          <field_lsb>13</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="I_12_12"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>I</field_name>
          <field_msb>12</field_msb>
          <field_lsb>12</field_lsb>
          <field_description order="before">
          
  <para>Instruction access Cacheability control, for accesses at EL2 and EL0:</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>All instruction access to Normal memory from EL2 and EL0 are Non-cacheable for all levels of instruction and unified cache.</para>
<para>If the value of SCTLR_EL2.M is 0, instruction accesses from stage 1 of the EL2&amp;0 translation regime are to Normal, Outer Shareable, Inner Non-cacheable, Outer Non-cacheable memory.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>This control has no effect on the Cacheability of instruction access to Normal memory from EL2 and EL0.</para>
<para>If the value of SCTLR_EL2.M is 0, instruction accesses from stage 1 of the EL2&amp;0 translation regime are to Normal, Outer Shareable, Inner Write-Through, Outer Write-Through memory.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>This bit has no effect on the EL3 translation regimes.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_number>0</field_reset_number>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="EOS_11_11_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES1"
        >
          <field_name>EOS</field_name>
          <field_msb>11</field_msb>
          <field_lsb>11</field_lsb>
          <field_description order="before">
          
  <para>Exception exit is a context synchronization event.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>An exception return from EL2 is not a context synchronization event.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>An exception return from EL2 is a context synchronization event.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>If SCTLR_EL2.EOS is set to <binarynumber>0b0</binarynumber>:</para>
<list type="unordered">
<listitem><content>Memory transactions, including instruction fetches, from an Exception level always use the translation resources associated with that translation regime.</content>
</listitem><listitem><content>Exception Catch debug events are synchronous debug events.</content>
</listitem><listitem><content>DCPS* and DRPS instructions are context synchronization events.</content>
</listitem></list>
<para>The following are not affected by the value of SCTLR_EL2.EOS:</para>
<list type="unordered">
<listitem><content>The indirect write of the PSTATE and PC values from <register_link state="AArch64" id="AArch64-spsr_el2.xml">SPSR_EL2</register_link> and <register_link state="AArch64" id="AArch64-elr_el2.xml">ELR_EL2</register_link> on exception return is synchronized. </content>
</listitem><listitem><content>Behavior of accessing the banked copies of the stack pointer using the SP register name for loads, stores and data processing instructions.</content>
</listitem><listitem><content>Exit from Debug state.</content>
</listitem></list>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_ExS is implemented</fields_condition>
      </field>
        <field
           id="1_11_11_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES1"
        >
          <field_name>1</field_name>
          <field_msb>11</field_msb>
          <field_lsb>11</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="EnRCTX_10_10_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>EnRCTX</field_name>
          <field_msb>10</field_msb>
          <field_lsb>10</field_lsb>
          <field_description order="before">
          
  <para>Enable EL0 Access to the following instructions:</para>
<list type="unordered">
<listitem><content>
<para>AArch32 CFPRCTX, DVPRCTX and CPPRCTX instructions.</para>
</content>
</listitem><listitem><content>
<para>AArch64 CFP RCTX, DVP RCT and CPP RCTX instructions.</para>
</content>
</listitem></list>
<para>The defined values are:</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>EL0 access to these instructions is disabled, and these instructions are trapped to EL1.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>EL0 access to these instructions is enabled.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_SPECRES is implemented</fields_condition>
      </field>
        <field
           id="0_10_10_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>10</field_msb>
          <field_lsb>10</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="0_9_9"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>9</field_msb>
          <field_lsb>9</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="SED_8_8_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES1"
        >
          <field_name>SED</field_name>
          <field_msb>8</field_msb>
          <field_lsb>8</field_lsb>
          <field_description order="before">
          
  <para>SETEND instruction disable. Disables SETEND instructions at EL0 using AArch32.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>SETEND instruction execution is enabled at EL0 using AArch32.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>SETEND instructions are <arm-defined-word>UNDEFINED</arm-defined-word> at EL0 using AArch32.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>If the implementation does not support mixed-endian operation at any Exception level, this bit is <arm-defined-word>RES1</arm-defined-word>.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When EL0 is capable of using AArch32</fields_condition>
      </field>
        <field
           id="1_8_8_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES1"
        >
          <field_name>1</field_name>
          <field_msb>8</field_msb>
          <field_lsb>8</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="ITD_7_7_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES1"
        >
          <field_name>ITD</field_name>
          <field_msb>7</field_msb>
          <field_lsb>7</field_lsb>
          <field_description order="before">
          
  <para>IT Disable. Disables some uses of IT instructions at EL0 using AArch32.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>All IT instruction functionality is enabled at EL0 using AArch32.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Any attempt at EL0 using AArch32 to execute any of the following is <arm-defined-word>UNDEFINED</arm-defined-word>:</para>
<list type="unordered">
<listitem><content>All encodings of the IT instruction with hw1[3:0]!=1000.</content>
</listitem><listitem><content>All encodings of the subsequent instruction with the following values for hw1:<list type="unordered">
<listitem><content><binarynumber>0b11xxxxxxxxxxxxxx</binarynumber>: All 32-bit instructions, and the 16-bit instructions B, UDF, SVC, LDM, and STM.</content>
</listitem><listitem><content><binarynumber>0b1011xxxxxxxxxxxx</binarynumber>: All instructions in 'Miscellaneous 16-bit instructions' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, section F3.2.5.</content>
</listitem><listitem><content><binarynumber>0b10100xxxxxxxxxxx</binarynumber>: ADD Rd, PC, #imm</content>
</listitem><listitem><content><binarynumber>0b01001xxxxxxxxxxx</binarynumber>: LDR Rd, [PC, #imm]</content>
</listitem><listitem><content><binarynumber>0b0100x1xxx1111xxx</binarynumber>: ADD Rdn, PC; CMP Rn, PC; MOV Rd, PC; BX PC; BLX PC.</content>
</listitem><listitem><content><binarynumber>0b010001xx1xxxx111</binarynumber>: ADD PC, Rm; CMP PC, Rm; MOV PC, Rm. This pattern also covers <arm-defined-word>UNPREDICTABLE</arm-defined-word> cases with BLX Rn.</content>
</listitem></list>
</content>
</listitem></list>
<para>These instructions are always <arm-defined-word>UNDEFINED</arm-defined-word>, regardless of whether they would pass or fail the condition code check that applies to them as a result of being in an IT block.</para>
<para>It is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> whether the IT instruction is treated as:</para>
<list type="unordered">
<listitem><content>A 16-bit instruction, that can only be followed by another 16-bit instruction.</content>
</listitem><listitem><content>The first half of a 32-bit instruction.</content>
</listitem></list>
<para>This means that, for the situations that are <arm-defined-word>UNDEFINED</arm-defined-word>, either the second 16-bit instruction or the 32-bit instruction is <arm-defined-word>UNDEFINED</arm-defined-word>.</para>
<para>An implementation might vary dynamically as to whether IT is treated as a 16-bit instruction or the first half of a 32-bit instruction.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>If an instruction in an active IT block that would be disabled by this field sets this field to 1 then behavior is <arm-defined-word>CONSTRAINED UNPREDICTABLE</arm-defined-word>. For more information see <xref browsertext="'Changes to an ITD control by an instruction in an IT block'" filename="E_the_aarch32_application_level_programmers__.fm" linkend="CJAHCDBA"></xref>.</para>
<para>ITD is optional, but if it is implemented in the <register_link state="AArch32" id="AArch32-sctlr.xml">SCTLR</register_link> then it must also be implemented in the SCTLR_EL1. If it is not implemented then this bit is RAZ/WI.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When EL0 is capable of using AArch32</fields_condition>
      </field>
        <field
           id="1_7_7_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES1"
        >
          <field_name>1</field_name>
          <field_msb>7</field_msb>
          <field_lsb>7</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="nAA_6_6_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>nAA</field_name>
          <field_msb>6</field_msb>
          <field_lsb>6</field_lsb>
          <field_description order="before">
          
  <para>Non-aligned access. This bit controls generation of Alignment faults at EL2 and EL0 under certain conditions.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>LDAPR, LDAPRH, LDAPUR, LDAPURH, LDAPURSH, LDAPURSW, LDAR, LDARH, LDLAR, LDLARH, STLLR, STLLRH, STLR, STLRH, STLUR, and STLURH generate an Alignment fault if all bytes being accessed are not within a single 16-byte quantity, aligned to 16 bytes for accesses.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>This control bit does not cause LDAPR, LDAPRH, LDAPUR, LDAPURH, LDAPURSH, LDAPURSW, LDAR, LDARH, LDLAR, LDLARH, STLLR, STLLRH, STLR, STLRH, STLUR, or STLURH to generate an Alignment fault if all bytes being accessed are not within a single 16-byte quantity, aligned to 16 bytes.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When FEAT_LSE2 is implemented</fields_condition>
      </field>
        <field
           id="0_6_6_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>6</field_msb>
          <field_lsb>6</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="CP15BEN_5_5_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           reserved_type="RES0"
        >
          <field_name>CP15BEN</field_name>
          <field_msb>5</field_msb>
          <field_lsb>5</field_lsb>
          <field_description order="before">
          
  <para>System instruction memory barrier enable. Enables accesses to the DMB, DSB, and ISB System instructions in the (coproc==<binarynumber>0b1111</binarynumber>) encoding space from EL0:</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>EL0 using AArch32: EL0 execution of the <register_link state="AArch32" id="AArch32-cp15dmb.xml">CP15DMB</register_link>, <register_link state="AArch32" id="AArch32-cp15dsb.xml">CP15DSB</register_link>, and <register_link state="AArch32" id="AArch32-cp15isb.xml">CP15ISB</register_link> instructions is <arm-defined-word>UNDEFINED</arm-defined-word>.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>EL0 using AArch32: EL0 execution of the <register_link state="AArch32" id="AArch32-cp15dmb.xml">CP15DMB</register_link>, <register_link state="AArch32" id="AArch32-cp15dsb.xml">CP15DSB</register_link>, and <register_link state="AArch32" id="AArch32-cp15isb.xml">CP15ISB</register_link> instructions is enabled.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>CP15BEN is optional, but if it is implemented in the <register_link state="AArch32" id="AArch32-sctlr.xml">SCTLR</register_link> then it must also be implemented in the SCTLR_EL1. If it is not implemented then this bit is RAO/WI.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
            <fields_condition>When EL0 is capable of using AArch32</fields_condition>
      </field>
        <field
           id="0_5_5_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
           rwtype="RES0"
        >
          <field_name>0</field_name>
          <field_msb>5</field_msb>
          <field_lsb>5</field_lsb>
          <field_description order="before">
            <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
          </field_description>
            <field_values>
            </field_values>
      </field>
        <field
           id="SA0_4_4"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>SA0</field_name>
          <field_msb>4</field_msb>
          <field_lsb>4</field_lsb>
          <field_description order="before">
          
  <para>SP Alignment check enable for EL0. When set to 1, if a load or store instruction executed at EL0 uses the SP as the base address and the SP is not aligned to a 16-byte boundary, then a SP alignment fault exception is generated. For more information, see <xref browsertext="'SP alignment checking'" filename="D_the_aarch64_system_level_programmers_model.fm" linkend="BEIHDCIE"></xref>.</para>

          </field_description>
            <field_values>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="SA_3_3"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>SA</field_name>
          <field_msb>3</field_msb>
          <field_lsb>3</field_lsb>
          <field_description order="before">
          
  <para>SP Alignment check enable. When set to 1, if a load or store instruction executed at EL2 uses the SP as the base address and the SP is not aligned to a 16-byte boundary, then a SP alignment fault exception is generated. For more information, see <xref browsertext="'SP alignment checking'" filename="D_the_aarch64_system_level_programmers_model.fm" linkend="BEIHDCIE"></xref>.</para>

          </field_description>
            <field_values>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="C_2_2"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>C</field_name>
          <field_msb>2</field_msb>
          <field_lsb>2</field_lsb>
          <field_description order="before">
          
  <para>Cacheability control, for data accesses.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>All data access to Normal memory from EL2 and EL0, and all Normal memory accesses to the EL2&amp;0 translation tables, are Non-cacheable for all levels of data and unified cache.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>This control has no effect on the Cacheability of:</para>
<list type="unordered">
<listitem><content>Data access to Normal memory from EL2 and EL0.</content>
</listitem><listitem><content>Normal memory accesses to the EL2&amp;0 translation tables.</content>
</listitem></list>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>This bit has no effect on the EL3 translation regimes.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_number>0</field_reset_number>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="A_1_1"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>A</field_name>
          <field_msb>1</field_msb>
          <field_lsb>1</field_lsb>
          <field_description order="before">
          
  <para>Alignment check enable. This is the enable bit for Alignment fault checking at EL2 and EL0.</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>Alignment fault checking disabled when executing at EL2 and EL0.</para>
<para>Instructions that load or store one or more registers, other than load/store exclusive and load-acquire/store-release, do not check that the address being accessed is aligned to the size of the data element(s) being accessed.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>Alignment fault checking enabled when executing at EL2 and EL0.</para>
<para>All instructions that load or store one or more registers have an alignment check that the address being accessed is aligned to the size of the data element(s) being accessed. If this check fails it causes an Alignment fault, which is taken as a Data Abort exception.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  <para>Load/store exclusive and load-acquire/store-release instructions have an alignment check regardless of the value of the A bit.</para>

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_standard_text>AU</field_reset_standard_text>
  
        </field_reset>
  
</field_resets>
      </field>
        <field
           id="M_0_0"
           is_variable_length="False"
           has_partial_fieldset="False"
           is_linked_to_partial_fieldset="False"
           is_access_restriction_possible="False"
           is_constant_value="False"
           is_partial_field="False"
        >
          <field_name>M</field_name>
          <field_msb>0</field_msb>
          <field_lsb>0</field_lsb>
          <field_description order="before">
          
  <para>MMU enable for EL2&amp;0 stage 1 address translation. Possible values of this bit are:</para>

          </field_description>
            <field_values>
                  <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
  <para>EL2&amp;0 stage 1 address translation disabled.</para>
<para>See the SCTLR_EL2.I field for the behavior of instruction accesses to Normal memory.</para>
</field_value_description>
    </field_value_instance>
                  <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
  <para>EL2&amp;0 stage 1 address translation enabled.</para>
</field_value_description>
    </field_value_instance>
            </field_values>
          <field_description order="after">
            
  

          </field_description>
          <field_resets>
  
  
    
    
        <field_reset>
          
      <field_reset_number>0</field_reset_number>
  
        </field_reset>
  
</field_resets>
      </field>
    <text_after_fields>
    
  

    </text_after_fields>
  </fields>
  <reg_fieldset length="64">
        <fields_condition>When HCR_EL2.E2H != 1 or HCR_EL2.TGE != 1</fields_condition>
      
        <fieldat id="0_63_45" msb="63" lsb="45"/>
        <fieldat id="DSSBS_44_44_1" msb="44" lsb="44"/>
        <fieldat id="ATA_43_43_1" msb="43" lsb="43"/>
        <fieldat id="0_42_42" msb="42" lsb="42"/>
        <fieldat id="TCF_41_40_1" msb="41" lsb="40"/>
        <fieldat id="0_39_38" msb="39" lsb="38"/>
        <fieldat id="ITFSB_37_37_1" msb="37" lsb="37"/>
        <fieldat id="BT_36_36_1" msb="36" lsb="36"/>
        <fieldat id="0_35_32" msb="35" lsb="32"/>
        <fieldat id="EnIA_31_31_1" msb="31" lsb="31"/>
        <fieldat id="EnIB_30_30_1" msb="30" lsb="30"/>
        <fieldat id="1_29_28" msb="29" lsb="28"/>
        <fieldat id="EnDA_27_27_1" msb="27" lsb="27"/>
        <fieldat id="0_26_26" msb="26" lsb="26"/>
        <fieldat id="EE_25_25" msb="25" lsb="25"/>
        <fieldat id="0_24_24" msb="24" lsb="24"/>
        <fieldat id="1_23_23" msb="23" lsb="23"/>
        <fieldat id="EIS_22_22_1" msb="22" lsb="22"/>
        <fieldat id="IESB_21_21_1" msb="21" lsb="21"/>
        <fieldat id="0_20_20" msb="20" lsb="20"/>
        <fieldat id="WXN_19_19" msb="19" lsb="19"/>
        <fieldat id="1_18_18" msb="18" lsb="18"/>
        <fieldat id="0_17_17" msb="17" lsb="17"/>
        <fieldat id="1_16_16" msb="16" lsb="16"/>
        <fieldat id="0_15_14" msb="15" lsb="14"/>
        <fieldat id="EnDB_13_13_1" msb="13" lsb="13"/>
        <fieldat id="I_12_12" msb="12" lsb="12"/>
        <fieldat id="EOS_11_11_1" msb="11" lsb="11"/>
        <fieldat id="0_10_7" msb="10" lsb="7"/>
        <fieldat id="nAA_6_6_1" msb="6" lsb="6"/>
        <fieldat id="1_5_4" msb="5" lsb="4"/>
        <fieldat id="SA_3_3" msb="3" lsb="3"/>
        <fieldat id="C_2_2" msb="2" lsb="2"/>
        <fieldat id="A_1_1" msb="1" lsb="1"/>
        <fieldat id="M_0_0" msb="0" lsb="0"/>
    </reg_fieldset>
  <reg_fieldset length="64">
        <fields_condition>When HCR_EL2.E2H == 1 and HCR_EL2.TGE == 1</fields_condition>
      
        <fieldat id="0_63_50" msb="63" lsb="50"/>
        <fieldat id="TWEDEL_49_46_1" msb="49" lsb="46"/>
        <fieldat id="TWEDEn_45_45_1" msb="45" lsb="45"/>
        <fieldat id="DSSBS_44_44_1" msb="44" lsb="44"/>
        <fieldat id="ATA_43_43_1" msb="43" lsb="43"/>
        <fieldat id="ATA0_42_42_1" msb="42" lsb="42"/>
        <fieldat id="TCF_41_40_1" msb="41" lsb="40"/>
        <fieldat id="TCF0_39_38_1" msb="39" lsb="38"/>
        <fieldat id="ITFSB_37_37_1" msb="37" lsb="37"/>
        <fieldat id="BT1_36_36_1" msb="36" lsb="36"/>
        <fieldat id="BT0_35_35_1" msb="35" lsb="35"/>
        <fieldat id="0_34_32" msb="34" lsb="32"/>
        <fieldat id="EnIA_31_31_1" msb="31" lsb="31"/>
        <fieldat id="EnIB_30_30_1" msb="30" lsb="30"/>
        <fieldat id="LSMAOE_29_29_1" msb="29" lsb="29"/>
        <fieldat id="nTLSMD_28_28_1" msb="28" lsb="28"/>
        <fieldat id="EnDA_27_27_1" msb="27" lsb="27"/>
        <fieldat id="UCI_26_26" msb="26" lsb="26"/>
        <fieldat id="EE_25_25" msb="25" lsb="25"/>
        <fieldat id="E0E_24_24" msb="24" lsb="24"/>
        <fieldat id="SPAN_23_23" msb="23" lsb="23"/>
        <fieldat id="EIS_22_22_1" msb="22" lsb="22"/>
        <fieldat id="IESB_21_21_1" msb="21" lsb="21"/>
        <fieldat id="TSCXT_20_20_1" msb="20" lsb="20"/>
        <fieldat id="WXN_19_19" msb="19" lsb="19"/>
        <fieldat id="nTWE_18_18" msb="18" lsb="18"/>
        <fieldat id="0_17_17" msb="17" lsb="17"/>
        <fieldat id="nTWI_16_16" msb="16" lsb="16"/>
        <fieldat id="UCT_15_15" msb="15" lsb="15"/>
        <fieldat id="DZE_14_14" msb="14" lsb="14"/>
        <fieldat id="EnDB_13_13_1" msb="13" lsb="13"/>
        <fieldat id="I_12_12" msb="12" lsb="12"/>
        <fieldat id="EOS_11_11_1" msb="11" lsb="11"/>
        <fieldat id="EnRCTX_10_10_1" msb="10" lsb="10"/>
        <fieldat id="0_9_9" msb="9" lsb="9"/>
        <fieldat id="SED_8_8_1" msb="8" lsb="8"/>
        <fieldat id="ITD_7_7_1" msb="7" lsb="7"/>
        <fieldat id="nAA_6_6_1" msb="6" lsb="6"/>
        <fieldat id="CP15BEN_5_5_1" msb="5" lsb="5"/>
        <fieldat id="SA0_4_4" msb="4" lsb="4"/>
        <fieldat id="SA_3_3" msb="3" lsb="3"/>
        <fieldat id="C_2_2" msb="2" lsb="2"/>
        <fieldat id="A_1_1" msb="1" lsb="1"/>
        <fieldat id="M_0_0" msb="0" lsb="0"/>
    </reg_fieldset>

      </reg_fieldsets>
      


<access_mechanisms>
  
    
      <access_permission_text>
        <para>When <register_link state="AArch64" id="AArch64-hcr_el2.xml">HCR_EL2</register_link>.E2H is 1, without explicit synchronization, access from EL2 using the mnemonic SCTLR_EL2 or SCTLR_EL1 are not guaranteed to be ordered with respect to accesses using the other mnemonic.</para>
      </access_permission_text>


      <access_mechanism accessor="MRS SCTLR_EL2">
        <encoding>
          
          <access_instruction>MRS &lt;Xt&gt;, SCTLR_EL2</access_instruction>
            
            <enc n="op0" v="0b11"/>
            
            <enc n="op1" v="0b100"/>
            
            <enc n="CRn" v="0b0001"/>
            
            <enc n="CRm" v="0b0000"/>
            
            <enc n="op2" v="0b000"/>
        </encoding>
          <access_permission>
            <ps name="MRS" sections="1" secttype="access_permission">
              <pstext>
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    return SCTLR_EL2;
elsif PSTATE.EL == EL3 then
    return SCTLR_EL2;
              </pstext>
            </ps>
          </access_permission>
      </access_mechanism>
      <access_mechanism accessor="MSRregister SCTLR_EL2">
        <encoding>
          
          <access_instruction>MSR SCTLR_EL2, &lt;Xt&gt;</access_instruction>
            
            <enc n="op0" v="0b11"/>
            
            <enc n="op1" v="0b100"/>
            
            <enc n="CRn" v="0b0001"/>
            
            <enc n="CRm" v="0b0000"/>
            
            <enc n="op2" v="0b000"/>
        </encoding>
          <access_permission>
            <ps name="MSRregister" sections="1" secttype="access_permission">
              <pstext>
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    SCTLR_EL2 = X[t];
elsif PSTATE.EL == EL3 then
    SCTLR_EL2 = X[t];
              </pstext>
            </ps>
          </access_permission>
      </access_mechanism>
      <access_mechanism accessor="MRS SCTLR_EL1">
        <encoding>
          
          <access_instruction>MRS &lt;Xt&gt;, SCTLR_EL1</access_instruction>
            
            <enc n="op0" v="0b11"/>
            
            <enc n="op1" v="0b000"/>
            
            <enc n="CRn" v="0b0001"/>
            
            <enc n="CRm" v="0b0000"/>
            
            <enc n="op2" v="0b000"/>
        </encoding>
          <access_permission>
            <ps name="MRS" sections="1" secttype="access_permission">
              <pstext>
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.TRVM == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HFGRTR_EL2.SCTLR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV&gt; == '111' then
        return NVMem[0x110];
    else
        return SCTLR_EL1;
elsif PSTATE.EL == EL2 then
    if HCR_EL2.E2H == '1' then
        return SCTLR_EL2;
    else
        return SCTLR_EL1;
elsif PSTATE.EL == EL3 then
    return SCTLR_EL1;
              </pstext>
            </ps>
          </access_permission>
      </access_mechanism>
      <access_mechanism accessor="MSRregister SCTLR_EL1">
        <encoding>
          
          <access_instruction>MSR SCTLR_EL1, &lt;Xt&gt;</access_instruction>
            
            <enc n="op0" v="0b11"/>
            
            <enc n="op1" v="0b000"/>
            
            <enc n="CRn" v="0b0001"/>
            
            <enc n="CRm" v="0b0000"/>
            
            <enc n="op2" v="0b000"/>
        </encoding>
          <access_permission>
            <ps name="MSRregister" sections="1" secttype="access_permission">
              <pstext>
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.TVM == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HFGWTR_EL2.SCTLR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV&gt; == '111' then
        NVMem[0x110] = X[t];
    else
        SCTLR_EL1 = X[t];
elsif PSTATE.EL == EL2 then
    if HCR_EL2.E2H == '1' then
        SCTLR_EL2 = X[t];
    else
        SCTLR_EL1 = X[t];
elsif PSTATE.EL == EL3 then
    SCTLR_EL1 = X[t];
              </pstext>
            </ps>
          </access_permission>
      </access_mechanism>
</access_mechanisms>

      <arch_variants>
      </arch_variants>
  </register>
</registers>

    <timestamp>01/07/2020 15:57; 80324f0b9997bede489cc15ad1565345720bcd2a</timestamp>
</register_page>